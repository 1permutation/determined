-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module DetQL.Object.Checkpoints exposing (..)

import CustomScalarCodecs
import DetQL.Enum.Trials_select_column
import DetQL.InputObject
import DetQL.Interface
import DetQL.Object
import DetQL.Scalar
import DetQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


end_time : SelectionSet (Maybe CustomScalarCodecs.Timestamptz) DetQL.Object.Checkpoints
end_time =
    Object.selectionForField "(Maybe CustomScalarCodecs.Timestamptz)" "end_time" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecTimestamptz |> .decoder |> Decode.nullable)


id : SelectionSet Int DetQL.Object.Checkpoints
id =
    Object.selectionForField "Int" "id" [] Decode.int


type alias LabelsOptionalArguments =
    { path : OptionalArgument String }


{-|

  - path - JSON select path

-}
labels : (LabelsOptionalArguments -> LabelsOptionalArguments) -> SelectionSet (Maybe CustomScalarCodecs.Jsonb) DetQL.Object.Checkpoints
labels fillInOptionals =
    let
        filledInOptionals =
            fillInOptionals { path = Absent }

        optionalArgs =
            [ Argument.optional "path" filledInOptionals.path Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForField "(Maybe CustomScalarCodecs.Jsonb)" "labels" optionalArgs (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecJsonb |> .decoder |> Decode.nullable)


type alias ResourcesOptionalArguments =
    { path : OptionalArgument String }


{-|

  - path - JSON select path

-}
resources : (ResourcesOptionalArguments -> ResourcesOptionalArguments) -> SelectionSet (Maybe CustomScalarCodecs.Jsonb) DetQL.Object.Checkpoints
resources fillInOptionals =
    let
        filledInOptionals =
            fillInOptionals { path = Absent }

        optionalArgs =
            [ Argument.optional "path" filledInOptionals.path Encode.string ]
                |> List.filterMap identity
    in
    Object.selectionForField "(Maybe CustomScalarCodecs.Jsonb)" "resources" optionalArgs (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecJsonb |> .decoder |> Decode.nullable)


start_time : SelectionSet CustomScalarCodecs.Timestamptz DetQL.Object.Checkpoints
start_time =
    Object.selectionForField "CustomScalarCodecs.Timestamptz" "start_time" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecTimestamptz |> .decoder)


state : SelectionSet CustomScalarCodecs.Checkpoint_state DetQL.Object.Checkpoints
state =
    Object.selectionForField "CustomScalarCodecs.Checkpoint_state" "state" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecCheckpoint_state |> .decoder)


{-| An object relationship
-}
step : SelectionSet decodesTo DetQL.Object.Steps -> SelectionSet (Maybe decodesTo) DetQL.Object.Checkpoints
step object_ =
    Object.selectionForCompositeField "step" [] object_ (identity >> Decode.nullable)


step_id : SelectionSet Int DetQL.Object.Checkpoints
step_id =
    Object.selectionForField "Int" "step_id" [] Decode.int


trial_id : SelectionSet Int DetQL.Object.Checkpoints
trial_id =
    Object.selectionForField "Int" "trial_id" [] Decode.int


type alias TrialsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trials_select_column.Trials_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trials_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trials_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trials : (TrialsOptionalArguments -> TrialsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trials -> SelectionSet (List decodesTo) DetQL.Object.Checkpoints
trials fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trials_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrials_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrials_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trials" optionalArgs object_ (identity >> Decode.list)


type alias TrialsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trials_select_column.Trials_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trials_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trials_bool_exp
    }


{-| An aggregated array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trials_aggregate : (TrialsAggregateOptionalArguments -> TrialsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trials_aggregate -> SelectionSet decodesTo DetQL.Object.Checkpoints
trials_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trials_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrials_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrials_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trials_aggregate" optionalArgs object_ identity


uuid : SelectionSet (Maybe CustomScalarCodecs.Uuid) DetQL.Object.Checkpoints
uuid =
    Object.selectionForField "(Maybe CustomScalarCodecs.Uuid)" "uuid" [] (CustomScalarCodecs.codecs |> DetQL.Scalar.unwrapCodecs |> .codecUuid |> .decoder |> Decode.nullable)


{-| An object relationship
-}
validation : SelectionSet decodesTo DetQL.Object.Validations -> SelectionSet (Maybe decodesTo) DetQL.Object.Checkpoints
validation object_ =
    Object.selectionForCompositeField "validation" [] object_ (identity >> Decode.nullable)
