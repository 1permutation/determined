-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module DetQL.Object.Users exposing (..)

import CustomScalarCodecs
import DetQL.Enum.Experiments_select_column
import DetQL.InputObject
import DetQL.Interface
import DetQL.Object
import DetQL.Scalar
import DetQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode


active : SelectionSet (Maybe Bool) DetQL.Object.Users
active =
    Object.selectionForField "(Maybe Bool)" "active" [] (Decode.bool |> Decode.nullable)


admin : SelectionSet (Maybe Bool) DetQL.Object.Users
admin =
    Object.selectionForField "(Maybe Bool)" "admin" [] (Decode.bool |> Decode.nullable)


{-| An object relationship
-}
agent_user_group : SelectionSet decodesTo DetQL.Object.Agent_user_groups -> SelectionSet (Maybe decodesTo) DetQL.Object.Users
agent_user_group object_ =
    Object.selectionForCompositeField "agent_user_group" [] object_ (identity >> Decode.nullable)


type alias ExperimentsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Experiments_select_column.Experiments_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Experiments_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Experiments_bool_exp
    }


{-| An array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
experiments : (ExperimentsOptionalArguments -> ExperimentsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Experiments -> SelectionSet (List decodesTo) DetQL.Object.Users
experiments fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Experiments_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeExperiments_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeExperiments_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "experiments" optionalArgs object_ (identity >> Decode.list)


type alias ExperimentsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Experiments_select_column.Experiments_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Experiments_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Experiments_bool_exp
    }


{-| An aggregated array relationship

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
experiments_aggregate : (ExperimentsAggregateOptionalArguments -> ExperimentsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Experiments_aggregate -> SelectionSet decodesTo DetQL.Object.Users
experiments_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Experiments_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeExperiments_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeExperiments_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "experiments_aggregate" optionalArgs object_ identity


id : SelectionSet Int DetQL.Object.Users
id =
    Object.selectionForField "Int" "id" [] Decode.int


username : SelectionSet String DetQL.Object.Users
username =
    Object.selectionForField "String" "username" [] Decode.string
