-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module DetQL.Subscription exposing (..)

import CustomScalarCodecs
import DetQL.Enum.Agent_user_groups_select_column
import DetQL.Enum.Checkpoints_select_column
import DetQL.Enum.Cluster_id_select_column
import DetQL.Enum.Config_files_select_column
import DetQL.Enum.Experiments_select_column
import DetQL.Enum.Searcher_events_select_column
import DetQL.Enum.Steps_select_column
import DetQL.Enum.Templates_select_column
import DetQL.Enum.Trial_logs_select_column
import DetQL.Enum.Trials_select_column
import DetQL.Enum.Users_select_column
import DetQL.Enum.Validation_metrics_select_column
import DetQL.Enum.Validations_select_column
import DetQL.InputObject
import DetQL.Interface
import DetQL.Object
import DetQL.Scalar
import DetQL.Union
import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)


type alias AgentUserGroupsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Agent_user_groups_select_column.Agent_user_groups_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Agent_user_groups_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Agent_user_groups_bool_exp
    }


{-| fetch data from the table: "agent\_user\_groups"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
agent_user_groups : (AgentUserGroupsOptionalArguments -> AgentUserGroupsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Agent_user_groups -> SelectionSet (List decodesTo) RootSubscription
agent_user_groups fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Agent_user_groups_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeAgent_user_groups_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeAgent_user_groups_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "agent_user_groups" optionalArgs object_ (identity >> Decode.list)


type alias AgentUserGroupsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Agent_user_groups_select_column.Agent_user_groups_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Agent_user_groups_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Agent_user_groups_bool_exp
    }


{-| fetch aggregated fields from the table: "agent\_user\_groups"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
agent_user_groups_aggregate : (AgentUserGroupsAggregateOptionalArguments -> AgentUserGroupsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Agent_user_groups_aggregate -> SelectionSet decodesTo RootSubscription
agent_user_groups_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Agent_user_groups_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeAgent_user_groups_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeAgent_user_groups_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "agent_user_groups_aggregate" optionalArgs object_ identity


type alias AgentUserGroupsByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "agent\_user\_groups" using primary key columns
-}
agent_user_groups_by_pk : AgentUserGroupsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Agent_user_groups -> SelectionSet (Maybe decodesTo) RootSubscription
agent_user_groups_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "agent_user_groups_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias BestCheckpointByMetricOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Checkpoints_select_column.Checkpoints_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Checkpoints_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Checkpoints_bool_exp
    }


type alias BestCheckpointByMetricRequiredArguments =
    { args : DetQL.InputObject.Best_checkpoint_by_metric_args }


{-| execute function "best\_checkpoint\_by\_metric" which returns "checkpoints"

  - args - input parameters for function "best\_checkpoint\_by\_metric"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
best_checkpoint_by_metric : (BestCheckpointByMetricOptionalArguments -> BestCheckpointByMetricOptionalArguments) -> BestCheckpointByMetricRequiredArguments -> SelectionSet decodesTo DetQL.Object.Checkpoints -> SelectionSet (List decodesTo) RootSubscription
best_checkpoint_by_metric fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Checkpoints_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeCheckpoints_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeCheckpoints_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "best_checkpoint_by_metric" (optionalArgs ++ [ Argument.required "args" requiredArgs.args DetQL.InputObject.encodeBest_checkpoint_by_metric_args ]) object_ (identity >> Decode.list)


type alias BestCheckpointByMetricAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Checkpoints_select_column.Checkpoints_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Checkpoints_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Checkpoints_bool_exp
    }


type alias BestCheckpointByMetricAggregateRequiredArguments =
    { args : DetQL.InputObject.Best_checkpoint_by_metric_args }


{-| execute function "best\_checkpoint\_by\_metric" and query aggregates on result of table type "checkpoints"

  - args - input parameters for function "best\_checkpoint\_by\_metric"
  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
best_checkpoint_by_metric_aggregate : (BestCheckpointByMetricAggregateOptionalArguments -> BestCheckpointByMetricAggregateOptionalArguments) -> BestCheckpointByMetricAggregateRequiredArguments -> SelectionSet decodesTo DetQL.Object.Checkpoints_aggregate -> SelectionSet decodesTo RootSubscription
best_checkpoint_by_metric_aggregate fillInOptionals requiredArgs object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Checkpoints_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeCheckpoints_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeCheckpoints_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "best_checkpoint_by_metric_aggregate" (optionalArgs ++ [ Argument.required "args" requiredArgs.args DetQL.InputObject.encodeBest_checkpoint_by_metric_args ]) object_ identity


type alias CheckpointsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Checkpoints_select_column.Checkpoints_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Checkpoints_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Checkpoints_bool_exp
    }


{-| fetch data from the table: "checkpoints"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
checkpoints : (CheckpointsOptionalArguments -> CheckpointsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Checkpoints -> SelectionSet (List decodesTo) RootSubscription
checkpoints fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Checkpoints_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeCheckpoints_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeCheckpoints_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "checkpoints" optionalArgs object_ (identity >> Decode.list)


type alias CheckpointsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Checkpoints_select_column.Checkpoints_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Checkpoints_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Checkpoints_bool_exp
    }


{-| fetch aggregated fields from the table: "checkpoints"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
checkpoints_aggregate : (CheckpointsAggregateOptionalArguments -> CheckpointsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Checkpoints_aggregate -> SelectionSet decodesTo RootSubscription
checkpoints_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Checkpoints_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeCheckpoints_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeCheckpoints_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "checkpoints_aggregate" optionalArgs object_ identity


type alias CheckpointsByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "checkpoints" using primary key columns
-}
checkpoints_by_pk : CheckpointsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Checkpoints -> SelectionSet (Maybe decodesTo) RootSubscription
checkpoints_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "checkpoints_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias ClusterIdOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Cluster_id_select_column.Cluster_id_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Cluster_id_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Cluster_id_bool_exp
    }


{-| fetch data from the table: "cluster\_id"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
cluster_id : (ClusterIdOptionalArguments -> ClusterIdOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Cluster_id -> SelectionSet (List decodesTo) RootSubscription
cluster_id fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Cluster_id_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeCluster_id_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeCluster_id_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "cluster_id" optionalArgs object_ (identity >> Decode.list)


type alias ClusterIdAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Cluster_id_select_column.Cluster_id_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Cluster_id_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Cluster_id_bool_exp
    }


{-| fetch aggregated fields from the table: "cluster\_id"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
cluster_id_aggregate : (ClusterIdAggregateOptionalArguments -> ClusterIdAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Cluster_id_aggregate -> SelectionSet decodesTo RootSubscription
cluster_id_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Cluster_id_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeCluster_id_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeCluster_id_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "cluster_id_aggregate" optionalArgs object_ identity


type alias ConfigFilesOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Config_files_select_column.Config_files_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Config_files_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Config_files_bool_exp
    }


{-| fetch data from the table: "config\_files"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
config_files : (ConfigFilesOptionalArguments -> ConfigFilesOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Config_files -> SelectionSet (List decodesTo) RootSubscription
config_files fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Config_files_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeConfig_files_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeConfig_files_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "config_files" optionalArgs object_ (identity >> Decode.list)


type alias ConfigFilesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Config_files_select_column.Config_files_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Config_files_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Config_files_bool_exp
    }


{-| fetch aggregated fields from the table: "config\_files"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
config_files_aggregate : (ConfigFilesAggregateOptionalArguments -> ConfigFilesAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Config_files_aggregate -> SelectionSet decodesTo RootSubscription
config_files_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Config_files_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeConfig_files_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeConfig_files_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "config_files_aggregate" optionalArgs object_ identity


type alias ConfigFilesByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "config\_files" using primary key columns
-}
config_files_by_pk : ConfigFilesByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Config_files -> SelectionSet (Maybe decodesTo) RootSubscription
config_files_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "config_files_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias ExperimentsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Experiments_select_column.Experiments_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Experiments_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Experiments_bool_exp
    }


{-| fetch data from the table: "experiments"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
experiments : (ExperimentsOptionalArguments -> ExperimentsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Experiments -> SelectionSet (List decodesTo) RootSubscription
experiments fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Experiments_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeExperiments_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeExperiments_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "experiments" optionalArgs object_ (identity >> Decode.list)


type alias ExperimentsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Experiments_select_column.Experiments_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Experiments_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Experiments_bool_exp
    }


{-| fetch aggregated fields from the table: "experiments"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
experiments_aggregate : (ExperimentsAggregateOptionalArguments -> ExperimentsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Experiments_aggregate -> SelectionSet decodesTo RootSubscription
experiments_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Experiments_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeExperiments_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeExperiments_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "experiments_aggregate" optionalArgs object_ identity


type alias ExperimentsByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "experiments" using primary key columns
-}
experiments_by_pk : ExperimentsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Experiments -> SelectionSet (Maybe decodesTo) RootSubscription
experiments_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "experiments_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias SearcherEventsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Searcher_events_select_column.Searcher_events_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Searcher_events_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Searcher_events_bool_exp
    }


{-| fetch data from the table: "searcher\_events"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
searcher_events : (SearcherEventsOptionalArguments -> SearcherEventsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Searcher_events -> SelectionSet (List decodesTo) RootSubscription
searcher_events fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Searcher_events_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeSearcher_events_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeSearcher_events_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "searcher_events" optionalArgs object_ (identity >> Decode.list)


type alias SearcherEventsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Searcher_events_select_column.Searcher_events_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Searcher_events_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Searcher_events_bool_exp
    }


{-| fetch aggregated fields from the table: "searcher\_events"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
searcher_events_aggregate : (SearcherEventsAggregateOptionalArguments -> SearcherEventsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Searcher_events_aggregate -> SelectionSet decodesTo RootSubscription
searcher_events_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Searcher_events_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeSearcher_events_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeSearcher_events_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "searcher_events_aggregate" optionalArgs object_ identity


type alias SearcherEventsByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "searcher\_events" using primary key columns
-}
searcher_events_by_pk : SearcherEventsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Searcher_events -> SelectionSet (Maybe decodesTo) RootSubscription
searcher_events_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "searcher_events_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias StepsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Steps_select_column.Steps_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Steps_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Steps_bool_exp
    }


{-| fetch data from the table: "steps"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
steps : (StepsOptionalArguments -> StepsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Steps -> SelectionSet (List decodesTo) RootSubscription
steps fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Steps_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeSteps_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeSteps_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "steps" optionalArgs object_ (identity >> Decode.list)


type alias StepsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Steps_select_column.Steps_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Steps_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Steps_bool_exp
    }


{-| fetch aggregated fields from the table: "steps"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
steps_aggregate : (StepsAggregateOptionalArguments -> StepsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Steps_aggregate -> SelectionSet decodesTo RootSubscription
steps_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Steps_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeSteps_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeSteps_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "steps_aggregate" optionalArgs object_ identity


type alias StepsByPkRequiredArguments =
    { id : Int
    , trial_id : Int
    }


{-| fetch data from the table: "steps" using primary key columns
-}
steps_by_pk : StepsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Steps -> SelectionSet (Maybe decodesTo) RootSubscription
steps_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "steps_by_pk" [ Argument.required "id" requiredArgs.id Encode.int, Argument.required "trial_id" requiredArgs.trial_id Encode.int ] object_ (identity >> Decode.nullable)


type alias TemplatesOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Templates_select_column.Templates_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Templates_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Templates_bool_exp
    }


{-| fetch data from the table: "templates"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
templates : (TemplatesOptionalArguments -> TemplatesOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Templates -> SelectionSet (List decodesTo) RootSubscription
templates fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Templates_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTemplates_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTemplates_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "templates" optionalArgs object_ (identity >> Decode.list)


type alias TemplatesAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Templates_select_column.Templates_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Templates_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Templates_bool_exp
    }


{-| fetch aggregated fields from the table: "templates"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
templates_aggregate : (TemplatesAggregateOptionalArguments -> TemplatesAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Templates_aggregate -> SelectionSet decodesTo RootSubscription
templates_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Templates_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTemplates_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTemplates_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "templates_aggregate" optionalArgs object_ identity


type alias TemplatesByPkRequiredArguments =
    { name : String }


{-| fetch data from the table: "templates" using primary key columns
-}
templates_by_pk : TemplatesByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Templates -> SelectionSet (Maybe decodesTo) RootSubscription
templates_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "templates_by_pk" [ Argument.required "name" requiredArgs.name Encode.string ] object_ (identity >> Decode.nullable)


type alias TrialLogsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trial_logs_select_column.Trial_logs_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trial_logs_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trial_logs_bool_exp
    }


{-| fetch data from the table: "trial\_logs"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trial_logs : (TrialLogsOptionalArguments -> TrialLogsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trial_logs -> SelectionSet (List decodesTo) RootSubscription
trial_logs fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trial_logs_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrial_logs_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrial_logs_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trial_logs" optionalArgs object_ (identity >> Decode.list)


type alias TrialLogsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trial_logs_select_column.Trial_logs_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trial_logs_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trial_logs_bool_exp
    }


{-| fetch aggregated fields from the table: "trial\_logs"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trial_logs_aggregate : (TrialLogsAggregateOptionalArguments -> TrialLogsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trial_logs_aggregate -> SelectionSet decodesTo RootSubscription
trial_logs_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trial_logs_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrial_logs_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrial_logs_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trial_logs_aggregate" optionalArgs object_ identity


type alias TrialLogsByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "trial\_logs" using primary key columns
-}
trial_logs_by_pk : TrialLogsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Trial_logs -> SelectionSet (Maybe decodesTo) RootSubscription
trial_logs_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "trial_logs_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias TrialsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trials_select_column.Trials_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trials_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trials_bool_exp
    }


{-| fetch data from the table: "trials"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trials : (TrialsOptionalArguments -> TrialsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trials -> SelectionSet (List decodesTo) RootSubscription
trials fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trials_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrials_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrials_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trials" optionalArgs object_ (identity >> Decode.list)


type alias TrialsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Trials_select_column.Trials_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Trials_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Trials_bool_exp
    }


{-| fetch aggregated fields from the table: "trials"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
trials_aggregate : (TrialsAggregateOptionalArguments -> TrialsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Trials_aggregate -> SelectionSet decodesTo RootSubscription
trials_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Trials_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeTrials_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeTrials_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "trials_aggregate" optionalArgs object_ identity


type alias TrialsByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "trials" using primary key columns
-}
trials_by_pk : TrialsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Trials -> SelectionSet (Maybe decodesTo) RootSubscription
trials_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "trials_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias UsersOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Users_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Users_bool_exp
    }


{-| fetch data from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users : (UsersOptionalArguments -> UsersOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Users -> SelectionSet (List decodesTo) RootSubscription
users fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "users" optionalArgs object_ (identity >> Decode.list)


type alias UsersAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Users_select_column.Users_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Users_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Users_bool_exp
    }


{-| fetch aggregated fields from the table: "users"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
users_aggregate : (UsersAggregateOptionalArguments -> UsersAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Users_aggregate -> SelectionSet decodesTo RootSubscription
users_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Users_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeUsers_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeUsers_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "users_aggregate" optionalArgs object_ identity


type alias UsersByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "users" using primary key columns
-}
users_by_pk : UsersByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Users -> SelectionSet (Maybe decodesTo) RootSubscription
users_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "users_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)


type alias ValidationMetricsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Validation_metrics_select_column.Validation_metrics_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Validation_metrics_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Validation_metrics_bool_exp
    }


{-| fetch data from the table: "validation\_metrics"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
validation_metrics : (ValidationMetricsOptionalArguments -> ValidationMetricsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Validation_metrics -> SelectionSet (List decodesTo) RootSubscription
validation_metrics fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Validation_metrics_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeValidation_metrics_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeValidation_metrics_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "validation_metrics" optionalArgs object_ (identity >> Decode.list)


type alias ValidationMetricsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Validation_metrics_select_column.Validation_metrics_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Validation_metrics_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Validation_metrics_bool_exp
    }


{-| fetch aggregated fields from the table: "validation\_metrics"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
validation_metrics_aggregate : (ValidationMetricsAggregateOptionalArguments -> ValidationMetricsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Validation_metrics_aggregate -> SelectionSet decodesTo RootSubscription
validation_metrics_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Validation_metrics_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeValidation_metrics_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeValidation_metrics_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "validation_metrics_aggregate" optionalArgs object_ identity


type alias ValidationsOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Validations_select_column.Validations_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Validations_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Validations_bool_exp
    }


{-| fetch data from the table: "validations"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
validations : (ValidationsOptionalArguments -> ValidationsOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Validations -> SelectionSet (List decodesTo) RootSubscription
validations fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Validations_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeValidations_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeValidations_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "validations" optionalArgs object_ (identity >> Decode.list)


type alias ValidationsAggregateOptionalArguments =
    { distinct_on : OptionalArgument (List DetQL.Enum.Validations_select_column.Validations_select_column)
    , limit : OptionalArgument Int
    , offset : OptionalArgument Int
    , order_by : OptionalArgument (List DetQL.InputObject.Validations_order_by)
    , where_ : OptionalArgument DetQL.InputObject.Validations_bool_exp
    }


{-| fetch aggregated fields from the table: "validations"

  - distinct\_on - distinct select on columns
  - limit - limit the number of rows returned
  - offset - skip the first n rows. Use only with order\_by
  - order\_by - sort the rows by one or more columns
  - where\_ - filter the rows returned

-}
validations_aggregate : (ValidationsAggregateOptionalArguments -> ValidationsAggregateOptionalArguments) -> SelectionSet decodesTo DetQL.Object.Validations_aggregate -> SelectionSet decodesTo RootSubscription
validations_aggregate fillInOptionals object_ =
    let
        filledInOptionals =
            fillInOptionals { distinct_on = Absent, limit = Absent, offset = Absent, order_by = Absent, where_ = Absent }

        optionalArgs =
            [ Argument.optional "distinct_on" filledInOptionals.distinct_on (Encode.enum DetQL.Enum.Validations_select_column.toString |> Encode.list), Argument.optional "limit" filledInOptionals.limit Encode.int, Argument.optional "offset" filledInOptionals.offset Encode.int, Argument.optional "order_by" filledInOptionals.order_by (DetQL.InputObject.encodeValidations_order_by |> Encode.list), Argument.optional "where" filledInOptionals.where_ DetQL.InputObject.encodeValidations_bool_exp ]
                |> List.filterMap identity
    in
    Object.selectionForCompositeField "validations_aggregate" optionalArgs object_ identity


type alias ValidationsByPkRequiredArguments =
    { id : Int }


{-| fetch data from the table: "validations" using primary key columns
-}
validations_by_pk : ValidationsByPkRequiredArguments -> SelectionSet decodesTo DetQL.Object.Validations -> SelectionSet (Maybe decodesTo) RootSubscription
validations_by_pk requiredArgs object_ =
    Object.selectionForCompositeField "validations_by_pk" [ Argument.required "id" requiredArgs.id Encode.int ] object_ (identity >> Decode.nullable)
